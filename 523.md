# Continuous Subarray Sum - LeetCode Editorial

## Problem Overview

Determine if there exists a subarray in the given integer array `nums` where the sum of its elements is divisible by an integer `k`.

**Key Constraints:**
1. The subarray must have a length of **at least two**
2. Must be solved in linear or log-linear time complexity

---

## Approach: Prefix Sum and Hashing

### Intuition

**Brute Force Analysis:**
- Calculate sum of all possible subarrays and check divisibility
- Number of subarrays: `n * (n - 1) / 2`
- Time complexity: O(n³) → **Time Limit Exceeded** ❌

**Optimized Solution:**
Use prefix sums to efficiently calculate subarray sums. The sum of subarray from index `i + 1` to `j` (inclusive) is:

```
sum[i+1...j] = prefix[j] - prefix[i]
```

**Key Mathematical Insight:**

If we want to check if a subarray sum is divisible by `k`:

```
(prefix[j] - prefix[i]) % k = 0
```

This is equivalent to:

```
prefix[j] % k = prefix[i] % k
```

**Therefore:** If two prefix sums have the same remainder when divided by `k`, the subarray between them is divisible by `k`!

### Visual Example

Consider `nums = [23, 2, 6, 4, 7]` and `k = 6`:

```
Index:        0   1   2   3   4
nums:        23   2   6   4   7
prefix_sum:  23  25  31  35  42
prefix_mod:   5   1   1   5   0
              ↑       ↑   ↑
              └───────┘   │
              Same mod!   │
              Subarray [2,6] sum=8? No, sum=6 ✓
                          │
                          └─→ mod 5 seen at index 0
                              Subarray [2,6,4] sum=12 ✓
```

When we see the same `prefix_mod` value again, we've found a subarray whose sum is divisible by `k`.

### Algorithm Steps

1. **Initialize:**
   - `prefixMod = 0` (tracks running remainder)
   - `modSeen = {0: -1}` (hashmap storing first occurrence of each remainder)
   - Initialize with `0: -1` to handle subarrays starting from index 0

2. **Iterate** through each element in `nums`:
   - Update: `prefixMod = (prefixMod + nums[i]) % k`
   - **If `prefixMod` exists in hashmap:**
     - Check if subarray length ≥ 2: `i - modSeen[prefixMod] > 1`
     - If yes, return `true`
   - **If `prefixMod` doesn't exist:**
     - Store it: `modSeen[prefixMod] = i`

3. **Return** `false` if no valid subarray found

### Why We Don't Update Existing Remainders

When we encounter a remainder we've seen before but the distance is too short, we **don't update** it. Why?

- We want to keep the **earliest occurrence** of each remainder
- This maximizes the subarray length for future checks
- Example: If we see remainder 5 at index 0 and again at index 1 (too short), we keep index 0 so that when we see it at index 2, we get a valid subarray of length 2

### Implementation

```python
class Solution:
    def checkSubarraySum(self, nums, k):
        prefixMod = 0
        modSeen = {0: -1}

        for i in range(len(nums)):
            prefixMod = (prefixMod + nums[i]) % k

            if prefixMod in modSeen:
                if i - modSeen[prefixMod] > 1:
                    return True
            else:
                modSeen[prefixMod] = i

        return False
```

### Detailed Walkthrough

**Example:** `nums = [23, 2, 4, 6, 7]`, `k = 6`

| Step | i | nums[i] | prefixMod | modSeen | Check | Result |
|------|---|---------|-----------|---------|-------|--------|
| Init | - | - | 0 | {0: -1} | - | - |
| 1 | 0 | 23 | 5 | {0: -1, 5: 0} | New mod | Continue |
| 2 | 1 | 2 | 1 | {0: -1, 5: 0, 1: 1} | New mod | Continue |
| 3 | 2 | 4 | 5 | {0: -1, 5: 0, 1: 1} | Seen at 0 | 2-0=2 > 1 ✓ |

**Result:** Return `true` at index 2. Subarray `[2, 4]` has sum = 6, which is divisible by 6.

### Edge Cases Handled

1. **Subarray starting from index 0:**
   - `modSeen = {0: -1}` handles this
   - Example: `[6, 3]`, `k=3` → prefix becomes 0 at index 1

2. **Adjacent zeros:**
   - `[0, 0]`, `k=1` → Returns `true` (both zeros sum to 0)

3. **Single remainder appearing multiple times:**
   - `[5, 0, 0, 0]`, `k=3` → First valid subarray at index 2

---

## Complexity Analysis

**Time Complexity:** O(n)
- Single pass through the array
- Each hashmap operation (lookup/insert) is O(1)
- Total: O(n)

**Space Complexity:** O(min(n, k))
- Hashmap stores at most `n` entries (one per index)
- But can only have at most `k` different remainders (0 to k-1)
- Therefore: O(min(n, k))

---

## Key Takeaways

✅ **Prefix sums** enable efficient subarray sum calculations  
✅ **Modular arithmetic** simplifies divisibility checks  
✅ **Hash map** provides O(1) lookups for seen remainders  
✅ **Store first occurrence** to maximize subarray length  
✅ **Initialize {0: -1}** to handle edge cases elegantly